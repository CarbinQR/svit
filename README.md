# svit
Сам проект знаходиться у `.\sources\svit`

Розгортання стандартне:
1. Скопіювати .env
2. `docker compose build`
3. `docker compose up` - проект піднімется на порту:`8089`
4. Через локальний артісан, або через контейнер згенерувати ключ `docker compose run artisan key:generate`
5. Далі виконати або `composer install`, або через контейнер `docker compose run composer update`

Так як вакансія бека, фронт робив тільки, щоб він виконував передачу та отримання данних без валідації.

Файли додаються через кнопку "Add files". Щоб отримати посилання на один\декілька файлів -
треби відмітити чекбоксом необхідні дампи та натиснути кнопку "Send". 

Після обробки запиту, якщо немає помилок, під кнопками "Add files" "Send" з'явиться перелік
посиланнь на завантажування .csv файлів. Кожне посилання клікабільне.
Нижче переліку буде кнопка "Merge CSV's". Натиснувши на кнопку, фронт збере всі посилання
на файли та відправить запит на їх об'єднання. Якщо запит пройде без помилок, до переліку посилань буде 
додано посилання на об'єднаний файл. Я не зробив уточнення, скоріше за все треба було надати можливість 
обрати у інтерфейсі, які саме таблиці треба об'єднати. Наразі цього немає, але бек приймає посилання які 
надіслані з фронту, тому бізнес логіка не потребує якихось масштабних змін. Лише додати код, який буде 
задавати біль гнучку назву для файлу.

Стосовно беку: для парсингу sql використовується парсер від PhpMyAdmin, для роботи з csv використовується 
пакет league\csv. 
Наразі реалізовано створення лише csv файлу, але league\csv має можливість створювати xml. Так як дампи мають
малий обсяг, читання та запис частинами не реалізовувалися, але за потреби, бізнес логіку можна швидко адаптувати 
під ці потреби. 

Про форматування у файлах: у рядках з контентон я не знайшов зображень, але додав регулярку яка прибирає теги `<img>`. 
Прибираються посилання з тексту, а в href атрібутах тегу `<a>` посилання заміняються на слеш. Спецсимволи екранізуються,
щоб записувались у файл так як вони є. Щоб назви та статті були у стовпяцх А і В відповідно, між ними ставиться `;`.

Із загального, зіткнувся з проблемою, що валідація дампів за правилами `mimetypes:application/sql,application/x-sql` не
пропускає дампи. Скоріше за все, це мій бік при передачі дампів з фронтової частини.
На реальному проекті, використовував би перенесення та збереження записів у файли, також при парсингу
дампів, по аналогії з пагінацією. Зробив би більш детальне відображення помилок, накшкалт скільки рядків не потрапило, у яких
файлах. 

Бізнес логіка працює наступним чином: 
 1. При створенні csv файлу: запит валідується через реквест(через проблему, що описана вижче, на файли стоїть валідація
тільки за правилом `file`), метод `createFromSql` у контроллері отримує масив дампів та передає їх в сервіс `SqlToCsvConverterService`
для подальшої обробки. Сервіс у методі convert приймає дампи та перебирає ії по одному. Сарвіс знаходить у дампі запит
на створення таблиці, ім'я якої є в константі ALLOWED_TABLES. Парсить запит на підзапити та знаходить індекси поля назви
та контенту статті. Серед підзапитів за індиксом витягує необхідні значення полів, зі значень видаляються посилання та зображення ,
а потім значення зберігаються у загальний масив. Після того як всі 
підзапити перебрані, йде перевірка чи є в загальному масиві якісь записи. Якщо є - викликає функцію `saveCsv`, щоб зберегти 
csv файл. В ідеалі, якщо немає контенту для створення файлу, я б повертав інформацію про те, що файл оброблено, але він пустий. 
У методі `saveCsv` створюється шлях для збереження файлу, та його назва. Назва файлу складається з назви дампу та поточної 
дати та часу, а шлях - у форматі дата/назва_файлу. Далі створюється файл куда вставляється масив з 
контентом (але для великих об'ємів краще робити аналогію пагінації). Далі йде перевірка чи всі строки з дампу залетіли у 
таблицу. У данній реалізації просто викидається ексепшен який припиняє загальне виконяння запту, на проекті краще після виконання
запиту повернути інформацію про проблемні файли. Якщо ж ніяких проблем немає, то `saveCsv` повертає лінку на створенний файл. Ця
лінка додається до масиву посилань і цикл переходить до наступного підзапиту. Після зашершення циклу, повертаємо в контроллер 
массив посилань на файли, а контроллер віддає їх у відповіді на запит.
2. При запиті на скачування файлу викликається `download` метод у контроллері. Метод через трейт отримує путь до файлу,
перевіряє, чи існує такий файл, та повертає його у відповіді.
3. При об'єднанні файлів, після валідації викликається метод `merge` який передає масив з посилання у сервіс `MergeCsvService`.
Сервіс приймає масив у методі merge, по схожій при створенні файлу логіці створює файл з таблицею, куди буде вносити контент
з файлів які треба об'єднати. Далі посилання перебираються у циклі, де посилання парситься для отримання шляху до файлу.
Відкривається файл, контент переноситься у загальний файл, порівнюється кількість рядків, яка очикується у загальному файлі
та фактична кількість рядків (по аналогії при створенні файлу). Після завершення циклу, у контроллер повертається посилання 
на загальний файл. 

